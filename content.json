{"pages":[],"posts":[{"title":"使用ssh进行远程连接","permalink":"http://lovin0730.github.io/2016/10/25/ssh-base/","text":"在开发场景中，开发人员免不了和服务器打交道，无论是连接服务器还是自己虚拟机中搭建的开发环境，都离不开SSH的应用。 SSH是一种网络协议，用于计算机之间的加密登陆。通过公钥加密进行信息保护，过程为： 远程主机收到用户登陆请求，发送公钥到用户。 用户用公钥加密密码发送到远程主机。 远程主机用私钥解密登录密码，密码正确则通过验证。 如果通信被截获，内容也是加密过的，而不会直接暴露出来，因此一直是主流的网络安全解决方案之一。SSH有很多种实现，我们下文所说的OpenSSH就是其中一种。 对于linux，一般使用的都是OpenSSH，对于尚未安装相应软件的机器，需要通过apt-get进行安装：$ sudo apt-get install openssh-server openssh-client 用SSH远程登陆时，通用的命令是(方括号中的内容是可选的)$ ssh [-p port] user@host user代表远程所使用的登陆名(需被远程机器上有此用户名) host代表远程机器的地址 默认会使用22作为远程主机的端口，如果你想改变端口，可以使用p参数 如果想要退出登陆，只需要输入exit就能退出了。 那么能不能不用每次输入密码登陆呢？当然可以，因为SSH支持公钥登陆。 首先简单讲讲公钥验证机制：公钥(public key)和私钥(private key)是两份文件，服务端持有公钥，用来加密；客户端持有私钥，用来解密。客户端向服务端发起连接请求时，服务端会生成一串随机数，经过公钥加密后传给客户端。这时客户端会用私钥解密获取随机数，再返回服务端。最后服务端判断一下，如果客户端能够返回正确的随机数，就认为校验通过了 ，可以进行连接。否则就不能连接。 用户需要提供自己的公钥，如果没有，可以生成一个，使用命令$ ssh-keygen这个命令会在默认为$HOME/.ssh/目录下生成两个文件，一个是id_rsa.pub(公钥)，另一个是id_rsa(私钥)，生成私钥的时候可能会询问你需要不需要设置口令(passphrase)，如果担心它的安全，可以设置一个。 接着你就可以传送公钥到想要访问的主机上面：$ ssh-copy-id user@host 从此登陆这台主机，就不需要密码了。需注意，主机的/etc/ssh/sshd_config文件中需存在以下命令。123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 有时需要在本地和远程机器间传送文件，我们可以使用scp命令来进行。 上传文件到远程目录：$ scp /path/file user@host:/path 从远程目录下载文件：$ scp user@host:/path/file /path 上传文件夹到远程目录：$ scp -r /path/dir user@host:/path 从远程目录下载文件夹：$ scp -r user@host:/path/dir /path 最后谈谈SSH的局限性： SSH存在一个风险，就是SSH的协议公钥是没有证书公证的，也就是说，可能存在“中间人”截获了登陆请求，并冒充远程主机将自己伪造的公钥发送给用户，就能得到用户接下来发送的密码。这种攻击叫做中间人攻击。 SSH解决的办法是在登陆时发送公钥指纹给用户，用户自己根据这一指纹和远程主机公布的指纹进行核对。用户也要自行承担风险。"},{"title":"JavaScript异步编程进化论","permalink":"http://lovin0730.github.io/2016/09/07/js-async/","text":"pixiv-ID: 16810195 众所周知，JavaScript的执行环境是单线程的，这意味着如果有很多任务，就只能排队一个一个执行。请看下面的例子。12345console.log(1);var X = 100000;for(let i = 0; i &lt; X; i++) &#123;&#125;console.log(2); 随着X的增大，打印1和2之间出现的时间间隔也在明显变长。对此，JavaScript采取异步来处理这种问题。12345console.log(1);setTimeout(() =&gt; &#123; console.log(2)&#125;, 2000);console.log(3) 事实上，打印的结果是1、3、2，setTimeout是一个典型的异步操作，所以JavaScript引擎执行到它时，会让它异步执行，而自己继续执行后面的任务，等到异步操作有了结果，再进行处理。但是异步编程的方法是值得讨论的，下面我用Node.js环境来进行后续的演示。1234567const http = require('http');http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); //TODO&#125;).listen(3000, console.log('callback running at localhost:3000')); 我创建了一个本地服务器，后面书写的所有代码都放在注释为TODO的位置执行。 Callback早期的大多数异步操作都是通过回调函数来完成的。下面我们用delay函数来模拟异步的数据获取(就像客户端通过Ajax或是服务端操作数据库所获取的数据)。123456789101112131415161718const delay = (msg, callback) =&gt; &#123; setTimeout(() =&gt; &#123; callback(msg + '\\n'); &#125;, 0);&#125;delay('delay begin', (data) =&gt; &#123; res.write(data); delay('delay end', (data) =&gt; &#123; res.write(data); delay('callback work', (data) =&gt; &#123; res.write(data); delay('done', (data) =&gt; &#123; res.write(data); res.end(); &#125;) &#125;) &#125;)&#125;); 我们发现问题的所在了，由于数据只能在回调函数内进行使用和操作，这导致了冗长的回调函数的出现，而且非常难以阅读。这就是著名的callback hell，对于需要连续进行异步操作的应用，这样的实现方案无疑是维护者的噩梦。 Promise因此，Promise应运而生，它改变了写法。请看下面的代码。1234567891011121314151617181920212223const delay = (msg) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(msg + '\\n'); &#125;, 0); &#125;);&#125;delay('delay begin').then((data) =&gt; &#123; res.write(data);&#125;).then(() =&gt; &#123; return delay('delay end');&#125;).then((data) =&gt; &#123; res.write(data);&#125;).then(() =&gt; &#123; return delay('promise work');&#125;).then((data) =&gt; &#123; res.write(data);&#125;).then(() =&gt; &#123; return delay('done');&#125;).then((data) =&gt; &#123; res.write(data); res.end();&#125;); 这样，我们就能通过链式调用来书写异步操作，任务先后顺序清晰易懂。只是，这份代码对于维护者显然也不是那么友好，要进行修改，就要对长长的链式调用进行阅读和修改。在度过jQuery时代时，这种写法的弊端已经暴漏无疑。 GeneratorES6为我们提供了更新的异步操作思路，那就是使用Generator函数。123456789101112131415161718const delay = (msg) =&gt; &#123; setTimeout(() =&gt; &#123; to.next(msg + '\\n'); &#125;, 100);&#125;function* todo() &#123; const begin = yield delay('delay begin'); res.write(begin); const end = yield delay('delay end'); res.write(end); const generator = yield delay('generator work'); res.write(generator); const done = yield delay('done'); res.write(done); res.end();&#125;let to = todo();to.next(); 我们可以通过在函数声明时加上星号创建Generator函数。它允许函数在执行过程中退出和重新进入，且重新进入时的环境（例如变量等）可以继续使用。调用Generator并不会立即执行，而是返回一个Iterator对象，每次调用这个对象的next方法，它会执行到第一个yield表达式之前，这个表达式定义了返回值以及返回状态。可以对next方法直接传入参数来规定返回值。其实，Generator想做的就是让异步编程越来越像同步编程。上述代码中我们发现它确实达到了目的，但是它也有显而易见的问题，那就是我们在书写异步操作时总要牢记什么时候要调用next，且异步操作和调用Generator函数生成的实例总要放在同一作用域，耦合度很高，再加上第一次的next方法要手动调用，因此这一方案注定还有很大的提升空间。 Thunk GeneratorThunk函数是一种高阶函数，它支持我们将一个带有回调函数作为参数的多参函数转化为单参版本。举个例子：12345678910111213141516//带回调函数作为参数的多参函数const delay = (msg, callback) =&gt; &#123; setTimeout(() =&gt; &#123; callback(msg); &#125;, 0);&#125;;//常规调用delay('your msg', () =&gt; &#123; //whatever&#125;);//Thunk化const delay_thunk = Thunk(delay);//Thunk化之后的调用delay('your msg')(() =&gt; &#123; //whatever&#125;); 如果我们使用Thunk化之后的delay函数，那么就有希望把generator函数中执行的异步函数和next方法分离开来，并制造出一个generator自动执行器。12345678910111213141516171819202122232425262728293031323334353637const Thunk = (f) =&gt; &#123; return (...args) =&gt; &#123; return (callback) =&gt; &#123; return f.call(this, ...args, callback); &#125; &#125;&#125;;const delay = (msg, callback) =&gt; &#123; setTimeout(() =&gt; &#123; callback(msg); &#125;, 0);&#125;const write = (pass) =&gt; &#123; res.write(pass + '\\n');&#125;const runG = (g) =&gt; &#123; const it = g(); !function next(data)&#123; let result = it.next(data); if (!result.done) &#123; result.value(next); &#125; &#125;();&#125;;const td = Thunk(delay);const todo = function* () &#123; const begin = yield td('delay begin'); const end = yield td('delay end'); const gValue = yield td('generator thunk value'); const done = yield td('done'); write(begin); write(end); write(gValue); write(done); res.end();&#125;runG(todo); 也许最难理解的就是自动处理generator的函数runG了，这个函数其实通过递归层层调用generator函数的next方法。这非常有意义，因为这下异步操作真正做到了将结果分离出来供外部进行使用和操作。 Promise Generator如果不想借助thunk函数，我们还可以使用promise，它还免去了我们手写Thunk函数的麻烦，请看代码。1234567891011121314151617181920212223242526272829303132333435const delay = (msg) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(msg); &#125;, 0); &#125;);&#125;const write = (pass) =&gt; &#123; res.write(pass + '\\n');&#125;const runG = (g) =&gt; &#123; const it = g(); !function next(data)&#123; let result = it.next(data); if (!result.done) &#123; result.value.then((data) =&gt; &#123; next(data); &#125;); &#125; else &#123; return result.value; &#125; &#125;();&#125;const todo = function* () &#123; const begin = yield delay('delay begin'); const end = yield delay('delay end'); const gValue = yield delay('generator thunk value'); const done = yield delay('done'); write(begin); write(end); write(gValue); write(done); res.end();&#125;runG(todo); AsyncES7提出了新的异步方案async，不过babel之类的转换器已经支持了它，async其实就是改变了generator函数的api，同时内置了自动执行函数。12345678910111213141516171819202122const delay = (msg) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(msg); &#125;, 0); &#125;);&#125;const write = (pass) =&gt; &#123; res.write(pass + '\\n');&#125;async function todo() &#123; const begin = await delay('delay begin'); const end = await delay('delay end'); const gValue = await delay('generator thunk value'); const done = await delay('done'); write(begin); write(end); write(gValue); write(done); res.end();&#125;const autoRun = todo(); 可以看到，就是将声明方式去掉了星号，在函数前加上了async前缀，并将yield替换为await，执行时，只需要进行一次调用，就能自动执行内部函数了。 总之，异步操作正变得越来越好理解，好使用，好维护，它目前进步的方向是变得越来越像同步操作。如果你想了解更多： 阮一峰的ES6入门教程 阮一峰关于Thunk函数的教程 MDN的Generator函数介绍 ES6 Generators: Complete Series BY Kyle Simpson系列教程 Promise迷你书 BY azu"},{"title":"使用MySQL配合Node.js进行简单session校验","permalink":"http://lovin0730.github.io/2016/09/04/nodejs-mysql-session/","text":"pixiv-ID: 52610961 session是web应用保持会话的一种相对安全有效又简单的方式，通常的做法是在每当客户端发起请求，服务端就会在返回的响应头信息中添加一个字段，同时将这个字段携带的信息记录在服务端。这样，当下次客户端发起请求的时候，服务端只要检查客户端携带的cookie，将它与服务端存储的数据做对比。就可以得知客户端当前状态，从而确保会话的连接了。 例如：当我第一次注册登录某网站，它记录了我的信息，并告诉我：“欢迎来到本网站！”，然后我不小心关掉了浏览器，再打开这个网站时惊喜的发现不用自己手动再登录一次了，但是当我三天没有访问它，它就会让我重新登录。这些就是通过session来完成的。 实现一个session的方式分为三步： 检查一个客户端请求是否携带约定字段。 若没带，说明是第一次访问。若带了，则根据该字段携带的值判断session是否超时（若超时可能需要重新登录等处理）。然后删除旧session，生成新的session。 将新生成的session的识别字段及所携带的值写入响应的头信息中的cookie中，返回客户端。 由于Node.js项目可能需要使用cluster，这导致session不能存储在缓存中，因此需要一个数据库，redis非常适合，但是由于项目刚好使用了MySQL，因此使用MySQL来存储session。在开始编写session之前，我们需要先封装几个简单的数据库操作。为此，我使用了一个node-mysql模块来帮助我进行工作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119var mysql = require('mysql');const pool = mysql.createPool(&#123; host: 'yourhost', user: 'youruser', database: 'yourdb', password: '*****', port: '3306', connectionLimit: 100&#125;);const createSchema = (schema, name) =&gt; &#123; return &#123; name: name, options: schema &#125;&#125;;const sessionSchema = createSchema( `( id VARCHAR(100) primary key, expire VARCHAR(50) )`, 'session');const operation = (connection, table) =&gt; &#123; this.createTable = (callback) =&gt; &#123; const action = 'CREATE TABLE IF NOT EXISTS ' + table.name + ' ' + table.options; connection.query(action, callback); &#125;; this.dropTable = (callback) =&gt; &#123; const action = 'DROP TABLE ' + table.name; connection.query(action, callback); &#125;; this.insertItem = (data, callback) =&gt; &#123; const action = 'INSERT INTO ' + table.name + ' SET ?'; connection.query(action, data, callback); &#125;; this.selectById = (id, callback) =&gt; &#123; const action = 'SELECT * FROM ' + table.name + ' WHERE id=' + pool.escape(id); connection.query(action, callback); &#125;; this.updateById = (id, data, callback) =&gt; &#123; const action = 'UPDATE ' + table.name + ' SET ? WHERE id=' + pool.escape(id); connection.query(action, data, callback); &#125;; this.deleteById = (id, callback) =&gt; &#123; const action = 'DELETE FROM ' + table.name + ' WHERE id=' + pool.escape(id); connection.query(action, callback); &#125;; this.release = () =&gt; &#123; connection.release(); &#125;; return this;&#125;;const connectPool = (callback, table) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; if(err) &#123; console.log('[query] - :' + err); return; &#125; console.log('[connection connect] succeed!'); const connect = operation(connection, table); callback(connect); &#125;);&#125;;const defaultCallback = (err, result) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(result); &#125;&#125;;const initTable = () =&gt; &#123; const createSessionTable = connectPool((connect) =&gt; &#123; connect.createTable(defaultCallback); connect.release(); &#125;, sessionSchema);&#125;;const manager = (mode) =&gt; &#123; const common = (callback) =&gt; &#123; return connectPool((connect) =&gt; &#123; callback(connect); connect.release(); &#125;, mode); &#125;; return &#123; create: () =&gt; &#123; common((connect) =&gt; &#123; connect.createTable(defaultCallback); &#125;); &#125;, add: (data) =&gt; &#123; common((connect) =&gt; &#123; connect.insertItem(data, defaultCallback); &#125;); &#125;, delete: (id) =&gt; &#123; common((connect) =&gt; &#123; connect.deleteById(id, defaultCallback); &#125;); &#125;, get: (id, callback) =&gt; &#123; common((connect) =&gt; &#123; connect.selectById(id, (err, result)=&gt;&#123; if (err) &#123; console.log(err); &#125; else &#123; callback(result); &#125; &#125;); &#125;); &#125;, update: (data) =&gt; &#123; common((connect) =&gt; &#123; connect.updateById(data.id, data, defaultCallback); &#125;); &#125;, &#125;&#125;initTable();const sessionManager = manager(sessionSchema); 这样我们就封装好了一个sessionManager，用来对session表进行增删查改的操作，这样封装的好处是如果有了新的table，只要在原代码的基础上新增相关schema即可，不需要修改和删除代码。 接下来我们可以进行服务端session校验的编写了。 确定session的时效EXPIRES和约定字段KEY，并用parseCookie解析请求中的cookie。 使用hackHead方法改写response方法使其响应客户端时能够携带session。 使用两个promisecheckExist和sessionMiddleWare来让异步操作更有条理，对session是否存在以及删除超时ssession，生成新session进行处理。 把后续操作放在handler中进行，这样就可以保证客户端是和我们保持通信的状态了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const http = require('http');const KEY = 'session_id';const EXPIRES = 20 * 60 * 1000;const generate = function() &#123; var session = &#123;&#125;; session.id = (new Date()).getTime() + Math.random().toFixed(2); session.expire = (new Date()).getTime() + EXPIRES; sessionManager.add(session); return session;&#125;const checkExist = (id) =&gt; &#123; var promise = new Promise((resolve, reject) =&gt; &#123; sessionManager.get(id, (session) =&gt; &#123; if (session) &#123; resolve(session); &#125; &#125;); &#125;); return promise;&#125;const parseCookie = (req) =&gt; &#123; if (req.headers.cookie)&#123; let cookies = &#123;&#125;; req.headers.cookie.split(';').forEach((cookie) =&gt; &#123; let parts = cookie.split('='); cookies[ parts[0].trim() ] = ( parts[1] || '').trim(); &#125;) return cookies; &#125; else &#123; return null; &#125;&#125;const hackHead = (sessions, req, res) =&gt; &#123; var writeHead = res.writeHead; res.writeHead = (status, headers) =&gt; &#123; let cookies = req.headers.cookie; let session = KEY + '=' + sessions.id; cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session]; res.setHeader('Set-Cookie', cookies); res.writeHead = writeHead; return res.writeHead(status, headers); &#125; return res.writeHead;&#125;const sessionMiddleWare = (req, res) =&gt; &#123; var promise = new Promise((resolve, reject) =&gt; &#123; const cookies = parseCookie(req); if(!cookies || !cookies[KEY]) &#123; const session = generate(user); res.writeHead = hackHead(session, req, res); const output = [req, res]; resolve(output); &#125; else &#123; checkExist(cookies[KEY]).then((session) =&gt; &#123; let newSession; if (session[0])&#123; session = session[0]; if (session.expire &gt; (new Date()).getTime()) &#123; newSession = session; newSession.expire = (new Date()).getTime() + EXPIRES; manager.update(newSession); &#125; else &#123; manager.delete(session.id); newSession = generate(user); &#125; &#125; else &#123; newSession = generate(user); &#125; return newSession; &#125;).then((session) =&gt; &#123; res.writeHead = hackHead(session, req, res); const output = [req, res]; resolve(output); &#125;); &#125; &#125;); return promise;&#125;const checkSession = (req, res, handler) =&gt; &#123; sessionMiddleWare(req, res).then((output) =&gt; &#123; handler(output[0], output[1]); &#125;);&#125;"},{"title":"CORS和Cookies","permalink":"http://lovin0730.github.io/2016/08/27/cors-and-cookies/","text":"pixiv-ID: 56852068 本次的项目是为一个短期活动搭建Node.js服务端，部署在服务器上后发现同事在自己的本机使用需要携带Cookie的AJAX请求调用接口的时候,受到了同源策略的限制。因此我们需要在服务端对跨域请求开放许可。 CORS是一个W3C标准， 全称是“跨域资源共享”（Cross-origin resource sharing）。它允许了浏览器向跨源服务器发送AJAX请求。（受限于同源策略，一般的AJAX不能跨域）。 跨域AJAX请求的发送源需要在服务端的许可名单之中，因此需要服务端对请求源开放许可。 本次项目中的服务端语言是Node.js，一般来说开放许可的做法为响应的头信息添加一些字段。 123456res.setHeader('Access-Control-Allow-Origin', *);//可以接受的源，*表示任意res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With');//预检的时候使用，指明请求中可以使用的自定义HTTP请求头res.setHeader('Access-Control-Allow-Methos', 'PUT, POST, GET, DELETE, OPTIONS');//预检的时候使用，指明资源可以被请求的方式 但是如果在请求的时候，需要携带Cookie时，我们就需要在服务端和客户端两端做一些处理 在客户端，我们需要给XMLHTTPRequest对象开启withCredentials属性，例如下面我封装的一个简单的AJAX请求。 12345678910111213141516171819202122function AJAX(method, URL, async, type, callback, data) &#123; var xhr = new XMLHttpRequest(); xhr.responseType = type; //开启withCredentials属性 xhr.withCredentials = true; xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var getRes = xhr.response; callback(getRes); &#125; &#125;; xhr.onerror = function (e) &#123; console.error(e); &#125;; xhr.open(method, URL, async); if (data) &#123; xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(data); &#125; else &#123; xhr.send(); &#125;&#125; 在服务端，我们需要为响应的头信息添加Access-Control-Allow-Credentials。这时服务端必须制定请求的域名，不再能使用’*’, 我们需要针对不同访问设定跨源允许域，这时HTTP请求头的Referer值就很好用了，当在一个域下发起一个CORS请求时，HTTP请求头的Referer会自动设置为页面域，此时只要我们在服务端根据Referer值构造出相应的Access-Control-Allow-Origin值即可。 1234567let origin = req.headers.referer;if (origin) &#123; origin = origin.match(/^http:\\/\\/+[a-zA-Z0-9\\.]+(\\:[0-9]+)?/);&#125;origin = origin ? origin[0] : 'your url';res.setHeader('Access-Control-Allow-Origin', origin);res.setHeader('Access-Control-Allow-Credentials', 'true'); 这样我们就可以尽情使用带Cookie的跨域了。 更多关于CORS可以阅读本篇使用Referer的灵感来自这里"},{"title":"实现温度曲线过程中的思考","permalink":"http://lovin0730.github.io/2016/07/15/temperature-curve/","text":"pixiv-ID: 50140585 上周接到的需求是实现QQ浏览器中的一个温度曲线。具体来说就是传入一组数据，数据包括6天的当日最高温度和最低温度，由此拟合出一条曲线。 曲线使用canvas进行绘制，因此有原生的贝塞尔曲线api可以使用。我们应该最大化的利用这个先天优势，避免过多的数学计算。 在这个需求中，有两个很有趣的点： 如果出现天气变化很小的情况：比如前四天气温都为22°~23°，第五天的变为23°~24°，那么曲线中这一变化是否应该表现的非常明显？ 给定的温度是一个区间，那么如何在这个区间中用一条平滑曲线较为准确的描绘出变化？ 需求的设计稿如下： 经过思考，个人认为处理上述两个问题的办法是: 如果温度变化情况很小，那么曲线的变化也不宜过大，以免给长期用户造成困扰。 这条曲线不采用描点-连线-折线转曲线的方式来描绘，也不采用点拟合曲线的方式来进行，理由如下： 描点-连线-折线转曲线面对的一个很棘手的问题就是对于曲线曲度的把握，而且需要进行的向量计算可能会对性能产生一些影响。 点拟合曲线是一个稳妥的方式，但是需要面对的问题是超大的计算量。而且对于气温变化大的城市很可能出现曲线偏离其中一点很远的情况。 综上所述，我采取了一种折线拟合曲线的方式，这个方式非常有趣，灵感来自这里 但是这个办法有一个很大的问题就是：书写上下温度值的时候如何确定在线上的点的Y坐标，我们需要一个算法去解决它。 因此代码核心分为三部分： 第一部分是如何让曲线变化根据温差大小进行适度的变化，温差大变化大，温差小变化小。且能够容纳足够的温度变化区间。 第二部分是如何把折线拟合为平滑曲线。 第三部分是确立算法求解特定点的Y坐标。 处理第一部分的办法是根据给定的数据计算出一个参考区间，然后根据这个参考区间来描绘曲线。例如，现在的温度数据是上图设计图所示的温度数据，那么理想的温度区间就是28~10。因此，首先要计算合理温度区间。其次，区间计算出来之后，我们在canvas上的坐标和温度在这个区间中的位置是成比例的，因此要计算温度点对应canvas画布中的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344var cfg = &#123; canvaswidth: 660, //画布宽度 canvasheight: 228, //画布高度 blankx: 0, //曲线横向留白 blankt: 30, //文字横向留白 blanky: 35 //曲线纵向留白&#125;;var setting = &#123; linewidth: 1, //曲线粗细 linecolor: '#fff', //曲线颜色 base: 5, //区间基准值 textsize: 24, //文字大小 textoffset: 34, //文字与曲线距离 textcolor: '#fff', //文字颜色 font: 'arial' //文字字体&#125;var getdata = function(data) &#123; var _getdata = [], _avarage; for (var _i = 0; _i &lt; data.length; _i++) &#123; _avarage = (data[_i][0] + data[_i][1]) / 2; _getdata.push(_avarage); &#125; return _getdata;&#125;var choseRank = function(getData) &#123; var _max = -Infinity, _min = Infinity, _res, _cur, _rank; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _cur = getData[_i]; if (_cur &gt; _max) &#123; _max = _cur; &#125; if (_cur &lt; _min) &#123; _min = _cur; &#125; &#125; _res = _max - _min; _rank = Math.round(_res / setting.base) + 1; return _rank * setting.base;&#125; 处理第二部分的办法就来自于上述那个链接中的灵感。假设我们有点A、B、C、D、E。那么我们以A为起点，B、C的中点为终点，B为参考点做贝塞尔曲线;然后接着以C、D的中点为终点，C为参考点做贝塞尔曲线，以此类推。123456789101112131415161718192021222324252627282930313233343536373839404142var draw_MAIN = function(canvas, data) &#123; var _dataGot = getData(data); var _rank = choseRank(_dataGot); var _totalPoint = _dataGot.length; var _sum = getSum(_dataGot); var _avr = Math.round(_sum / _totalPoint); var _low = _avr - _rank / 2, _high = _avr + _rank / 2, _interval = (cfg.canvasWidth - cfg.blankX * 2) / (_totalPoint - 1), _intervalT = (cfg.canvasWidth - cfg.blankT * 2) / (_totalPoint - 1), _curSupport, _cur, _next; var _curPoint = cfg.blankX; var getY = function(i) &#123; return cfg.canvasHeight - cfg.blankY - (_dataGot[i] - _low) * (cfg.canvasHeight - cfg.blankY * 2) / _rank; &#125; if (canvas.getContext) &#123; var _ctx = canvas.getContext('2d'); _ctx.imageSmoothingEnabled = true; _ctx.strokeStyle = setting.lineColor; _ctx.lineWidth = setting.lineWidth; _ctx.lineCap = 'round'; _ctx.beginPath(); _ctx.moveTo(_curPoint, getY(0)); for (var _i = 0; _i &lt; _dataGot.length - 1; _i++) &#123; _cur = getY(_i + 1); _next = getY(_i + 2); _curSupport = getSupportPoint(_cur, _next); if (_i &lt; _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint + _interval, _cur, _curPoint + _interval * 1.5, _curSupport); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint, getY(_i), _curPoint + _interval, _cur); &#125; _curPoint += _interval; _ctx.stroke(); &#125; &#125;&#125; 这时我们需要一个算法来计算出bezier-curve上特定点的坐标，canvas没有给我们提供相应的api，需要我们根据bezier函数自己来完成，这里我放上两个参考链接 贝塞尔曲线初探stackoverflow上的问题 最后得出的函数为： 1234567891011121314151617181920212223var getYValues = function(start, control, end, X) &#123; var _q1, _q2, _q3, _t, _y; _q1 = 2 * start.x - 2 * control.x; _q2 = Math.sqrt(5 * start.x * start.x - 10 * start.x * control.x + start.x * end.x - start.x * X + 2 * control.x * X + 4 * control.x * control.x ); _q3 = 2 * start.x - 4 * control.x + 2 * end.x; if (_q3 !== 0) &#123; _t = (_q1 + _q2) / _q3; &#125; else &#123; _t = ( X - start.x) / (2*control.x - 2*start.x); &#125; if (_t &lt; 0) &#123; _t = -1 * _t; &#125; _y = start.y * (1 - _t) * (1 - _t) + control.y * 2 * (1 - _t) * _t + end.y * _t * _t; return _y;&#125; 需要注意的是canvas绘制曲线会产生锯齿，除了开启浏览器抗锯齿以外，按照二倍图来绘制然后再缩小也是行之有效的方法，这里给出一个笨办法：1234567891011var setScale = function(num, cfg, setting) &#123; cfg.canvasWidth *= num; cfg.canvasHeight *= num; cfg.blankX *= num; cfg.blankT *= num; cfg.blankY *= num; setting.lineWidth *= num; setting.base *= num; setting.textSize *= num; setting.textOffSet *= num;&#125; 所以最终代码为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function drawTemperature(canvas, data) &#123; var cfg = &#123; canvasWidth: 660, //画布宽度 canvasHeight: 228, //画布高度 blankX: 0, //曲线横向留白 blankT: 30, //文字横向留白 blankY: 35 //曲线纵向留白 &#125;; var setting = &#123; lineWidth: 1, //曲线粗细 lineColor: '#fff', //曲线颜色 base: 5, //区间基准值 textSize: 24, //文字大小 textOffSet: 34, //文字与曲线距离 textColor: '#fff', //文字颜色 font: 'arial' //文字字体 &#125; var getData = function(data) &#123; var _getData = [], _avarage; for (var _i = 0; _i &lt; data.length; _i++) &#123; _avarage = (data[_i][0] + data[_i][1]) / 2; _getData.push(_avarage); &#125; return _getData; &#125; var choseRank = function(getData) &#123; var _max = -Infinity, _min = Infinity, _res, _cur, _rank; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _cur = getData[_i]; if (_cur &gt; _max) &#123; _max = _cur; &#125; if (_cur &lt; _min) &#123; _min = _cur; &#125; &#125; _res = _max - _min; _rank = Math.round(_res / setting.base) + 1; return _rank * setting.base; &#125; var getYValues = function(start, control, end, X) &#123; var _q1, _q2, _q3, _t, _y; _q1 = 2 * start.x - 2 * control.x; _q2 = Math.sqrt(5 * start.x * start.x - 10 * start.x * control.x + start.x * end.x - start.x * X + 2 * control.x * X + 4 * control.x * control.x ); _q3 = 2 * start.x - 4 * control.x + 2 * end.x; if (_q3 !== 0) &#123; _t = (_q1 + _q2) / _q3; &#125; else &#123; _t = ( X - start.x) / (2*control.x - 2*start.x); &#125; if (_t &lt; 0) &#123; _t = -1 * _t; &#125; _y = start.y * (1 - _t) * (1 - _t) + control.y * 2 * (1 - _t) * _t + end.y * _t * _t; return _y; &#125; var setScale = function(num, cfg, setting) &#123; cfg.canvasWidth *= num; cfg.canvasHeight *= num; cfg.blankX *= num; cfg.blankT *= num; cfg.blankY *= num; setting.lineWidth *= num; setting.base *= num; setting.textSize *= num; setting.textOffSet *= num; &#125; var getSum = function(getData) &#123; var _sum = 0; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _sum = _sum + getData[_i]; &#125; return _sum; &#125; var getSupportPoint = function(prev, next) &#123; return (prev + next) / 2; &#125; var draw_MAIN = function(canvas, data) &#123; setScale(2, cfg, setting); var _dataGot = getData(data); var _rank = choseRank(_dataGot); var _totalPoint = _dataGot.length; var _sum = getSum(_dataGot); var _avr = Math.round(_sum / _totalPoint); var _low = _avr - _rank / 2, _high = _avr + _rank / 2, _interval = (cfg.canvasWidth - cfg.blankX * 2) / (_totalPoint - 1), _intervalT = (cfg.canvasWidth - cfg.blankT * 2) / (_totalPoint - 1), _start = &#123;&#125;, _control = &#123;&#125;, _end = &#123;&#125;, _Y, _curSupport, _cur, _next; var _curPoint = cfg.blankX; var _curPointT = cfg.blankT; var getY = function(i) &#123; return cfg.canvasHeight - cfg.blankY - (_dataGot[i] - _low) * (cfg.canvasHeight - cfg.blankY * 2) / _rank; &#125; if (canvas.getContext) &#123; var _ctx = canvas.getContext('2d'); _ctx.imageSmoothingEnabled = true; _ctx.strokeStyle = setting.lineColor; _ctx.lineWidth = setting.lineWidth; _ctx.lineCap = 'round'; _ctx.font = setting.textSize + 'px ' + setting.font; _ctx.fillStyle = setting.textColor; _ctx.textAlign = 'center'; _ctx.textBaseline = 'middle'; _ctx.fillText(data[0][1] + \"°\", _curPointT, getY(0) - setting.textOffSet); _ctx.fillText(data[0][0] + \"°\", _curPointT, getY(0) + setting.textOffSet); _ctx.beginPath(); _ctx.moveTo(_curPoint, getY(0)); for (var _i = 0; _i &lt; _dataGot.length - 1; _i++) &#123; _cur = getY(_i + 1); _next = getY(_i + 2); _curSupport = getSupportPoint(_cur, _next); if (_i === 0) &#123; _start.x = _curPoint; _start.y = getY(0); _control.x = _curPoint + _interval; _control.y = _cur; _end.x = _curPoint + _interval * 1.5; _end.y = _curSupport; _Y = getYValues(_start, _control, _end, _curPoint + _interval); &#125; else if (_i &lt; _dataGot.length - 2) &#123; _start.x = _curPoint + _interval * 0.5; _start.y = getSupportPoint(getY(_i), getY(_i + 1)); _control.x = _curPoint + _interval; _control.y = _cur; _end.x = _curPoint + _interval * 1.5; _end.y = _curSupport; _Y = getYValues(_start, _control, _end, _control.x); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _Y = _cur; &#125; if (_i &lt; _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint + _interval, _cur, _curPoint + _interval * 1.5, _curSupport); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint, getY(_i), _curPoint + _interval, _cur); &#125; _curPoint += _interval; _ctx.stroke(); _curPointT += _intervalT; _ctx.fillText(data[_i + 1][1] + \"°\", _curPointT, _Y - setting.textOffSet); _ctx.fillText(data[_i + 1][0] + \"°\", _curPointT, _Y + setting.textOffSet); &#125; &#125; &#125; draw_MAIN(canvas,data);&#125;"}]}