{"pages":[],"posts":[{"title":"CORS和Cookies","permalink":"http://lovin0730.github.io/2016/08/27/cors-and-cookies/","text":"pixiv-ID: 56852068 本次的项目是为一个短期活动搭建Node.js服务端，部署在服务器上后发现同事在自己的本机使用需要携带Cookie的AJAX请求调用接口的时候,受到了同源策略的限制。因此我们需要在服务端对跨域请求开放许可。 CORS是一个W3C标准， 全称是“跨域资源共享”（Cross-origin resource sharing）。它允许了浏览器向跨源服务器发送AJAX请求。（受限于同源策略，一般的AJAX不能跨域）。 跨域AJAX请求的发送源需要在服务端的许可名单之中，因此需要服务端对请求源开放许可。 本次项目中的服务端语言是Node.js，一般来说开放许可的做法为响应的头信息添加一些字段。 123456res.setHeader('Access-Control-Allow-Origin', *);//可以接受的源，*表示任意res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With');//预检的时候使用，指明请求中可以使用的自定义HTTP请求头res.setHeader('Access-Control-Allow-Methos', 'PUT, POST, GET, DELETE, OPTIONS');//预检的时候使用，指明资源可以被请求的方式 但是如果在请求的时候，需要携带Cookie时，我们就需要在服务端和客户端两端做一些处理 在客户端，我们需要给XMLHTTPRequest对象开启withCredentials属性，例如下面我封装的一个简单的AJAX请求。 12345678910111213141516171819202122function AJAX(method, URL, async, type, callback, data) &#123; var xhr = new XMLHttpRequest(); xhr.responseType = type; //开启withCredentials属性 xhr.withCredentials = true; xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var getRes = xhr.response; callback(getRes); &#125; &#125;; xhr.onerror = function (e) &#123; console.error(e); &#125;; xhr.open(method, URL, async); if (data) &#123; xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(data); &#125; else &#123; xhr.send(); &#125;&#125; 在服务端，我们需要为响应的头信息添加Access-Control-Allow-Credentials。这时服务端必须制定请求的域名，不再能使用’*’, 我们需要针对不同访问设定跨源允许域，这时HTTP请求头的Referer值就很好用了，当在一个域下发起一个CORS请求时，HTTP请求头的Referer会自动设置为页面域，此时只要我们在服务端根据Referer值构造出相应的Access-Control-Allow-Origin值即可。 1234567let origin = req.headers.referer;if (origin) &#123; origin = origin.match(/^http:\\/\\/+[a-zA-Z0-9\\.]+(\\:[0-9]+)?/);&#125;origin = origin ? origin[0] : 'your url';res.setHeader('Access-Control-Allow-Origin', origin);res.setHeader('Access-Control-Allow-Credentials', 'true'); 这样我们就可以尽情使用带Cookie的跨域了。 更多关于CORS可以阅读本篇使用Referer的灵感来自这里"},{"title":"实现温度曲线过程中的思考","permalink":"http://lovin0730.github.io/2016/07/15/temperature-curve/","text":"pixiv-ID: 50140585 上周接到的需求是实现QQ浏览器中的一个温度曲线。具体来说就是传入一组数据，数据包括6天的当日最高温度和最低温度，由此拟合出一条曲线。 曲线使用canvas进行绘制，因此有原生的贝塞尔曲线api可以使用。我们应该最大化的利用这个先天优势，避免过多的数学计算。 在这个需求中，有两个很有趣的点： 如果出现天气变化很小的情况：比如前四天气温都为22°~23°，第五天的变为23°~24°，那么曲线中这一变化是否应该表现的非常明显？ 给定的温度是一个区间，那么如何在这个区间中用一条平滑曲线较为准确的描绘出变化？ 需求的设计稿如下： 经过思考，个人认为处理上述两个问题的办法是: 如果温度变化情况很小，那么曲线的变化也不宜过大，以免给长期用户造成困扰。 这条曲线不采用描点-连线-折线转曲线的方式来描绘，也不采用点拟合曲线的方式来进行，理由如下： 描点-连线-折线转曲线面对的一个很棘手的问题就是对于曲线曲度的把握，而且需要进行的向量计算可能会对性能产生一些影响。 点拟合曲线是一个稳妥的方式，但是需要面对的问题是超大的计算量。而且对于气温变化大的城市很可能出现曲线偏离其中一点很远的情况。 综上所述，我采取了一种折线拟合曲线的方式，这个方式非常有趣，灵感来自这里 但是这个办法有一个很大的问题就是：书写上下温度值的时候如何确定在线上的点的Y坐标，我们需要一个算法去解决它。 因此代码核心分为三部分： 第一部分是如何让曲线变化根据温差大小进行适度的变化，温差大变化大，温差小变化小。且能够容纳足够的温度变化区间。 第二部分是如何把折线拟合为平滑曲线。 第三部分是确立算法求解特定点的Y坐标。 处理第一部分的办法是根据给定的数据计算出一个参考区间，然后根据这个参考区间来描绘曲线。例如，现在的温度数据是上图设计图所示的温度数据，那么理想的温度区间就是28~10。因此，首先要计算合理温度区间。其次，区间计算出来之后，我们在canvas上的坐标和温度在这个区间中的位置是成比例的，因此要计算温度点对应canvas画布中的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344var cfg = &#123; canvaswidth: 660, //画布宽度 canvasheight: 228, //画布高度 blankx: 0, //曲线横向留白 blankt: 30, //文字横向留白 blanky: 35 //曲线纵向留白&#125;;var setting = &#123; linewidth: 1, //曲线粗细 linecolor: '#fff', //曲线颜色 base: 5, //区间基准值 textsize: 24, //文字大小 textoffset: 34, //文字与曲线距离 textcolor: '#fff', //文字颜色 font: 'arial' //文字字体&#125;var getdata = function(data) &#123; var _getdata = [], _avarage; for (var _i = 0; _i &lt; data.length; _i++) &#123; _avarage = (data[_i][0] + data[_i][1]) / 2; _getdata.push(_avarage); &#125; return _getdata;&#125;var choseRank = function(getData) &#123; var _max = -Infinity, _min = Infinity, _res, _cur, _rank; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _cur = getData[_i]; if (_cur &gt; _max) &#123; _max = _cur; &#125; if (_cur &lt; _min) &#123; _min = _cur; &#125; &#125; _res = _max - _min; _rank = Math.round(_res / setting.base) + 1; return _rank * setting.base;&#125; 处理第二部分的办法就来自于上述那个链接中的灵感。假设我们有点A、B、C、D、E。那么我们以A为起点，B、C的中点为终点，B为参考点做贝塞尔曲线;然后接着以C、D的中点为终点，C为参考点做贝塞尔曲线，以此类推。123456789101112131415161718192021222324252627282930313233343536373839404142var draw_MAIN = function(canvas, data) &#123; var _dataGot = getData(data); var _rank = choseRank(_dataGot); var _totalPoint = _dataGot.length; var _sum = getSum(_dataGot); var _avr = Math.round(_sum / _totalPoint); var _low = _avr - _rank / 2, _high = _avr + _rank / 2, _interval = (cfg.canvasWidth - cfg.blankX * 2) / (_totalPoint - 1), _intervalT = (cfg.canvasWidth - cfg.blankT * 2) / (_totalPoint - 1), _curSupport, _cur, _next; var _curPoint = cfg.blankX; var getY = function(i) &#123; return cfg.canvasHeight - cfg.blankY - (_dataGot[i] - _low) * (cfg.canvasHeight - cfg.blankY * 2) / _rank; &#125; if (canvas.getContext) &#123; var _ctx = canvas.getContext('2d'); _ctx.imageSmoothingEnabled = true; _ctx.strokeStyle = setting.lineColor; _ctx.lineWidth = setting.lineWidth; _ctx.lineCap = 'round'; _ctx.beginPath(); _ctx.moveTo(_curPoint, getY(0)); for (var _i = 0; _i &lt; _dataGot.length - 1; _i++) &#123; _cur = getY(_i + 1); _next = getY(_i + 2); _curSupport = getSupportPoint(_cur, _next); if (_i &lt; _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint + _interval, _cur, _curPoint + _interval * 1.5, _curSupport); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint, getY(_i), _curPoint + _interval, _cur); &#125; _curPoint += _interval; _ctx.stroke(); &#125; &#125;&#125; 这时我们需要一个算法来计算出bezier-curve上特定点的坐标，canvas没有给我们提供相应的api，需要我们根据bezier函数自己来完成，这里我放上两个参考链接 贝塞尔曲线初探stackoverflow上的问题 最后得出的函数为： 1234567891011121314151617181920212223var getYValues = function(start, control, end, X) &#123; var _q1, _q2, _q3, _t, _y; _q1 = 2 * start.x - 2 * control.x; _q2 = Math.sqrt(5 * start.x * start.x - 10 * start.x * control.x + start.x * end.x - start.x * X + 2 * control.x * X + 4 * control.x * control.x ); _q3 = 2 * start.x - 4 * control.x + 2 * end.x; if (_q3 !== 0) &#123; _t = (_q1 + _q2) / _q3; &#125; else &#123; _t = ( X - start.x) / (2*control.x - 2*start.x); &#125; if (_t &lt; 0) &#123; _t = -1 * _t; &#125; _y = start.y * (1 - _t) * (1 - _t) + control.y * 2 * (1 - _t) * _t + end.y * _t * _t; return _y;&#125; 需要注意的是canvas绘制曲线会产生锯齿，除了开启浏览器抗锯齿以外，按照二倍图来绘制然后再缩小也是行之有效的方法，这里给出一个笨办法：1234567891011var setScale = function(num, cfg, setting) &#123; cfg.canvasWidth *= num; cfg.canvasHeight *= num; cfg.blankX *= num; cfg.blankT *= num; cfg.blankY *= num; setting.lineWidth *= num; setting.base *= num; setting.textSize *= num; setting.textOffSet *= num;&#125; 所以最终代码为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function drawTemperature(canvas, data) &#123; var cfg = &#123; canvasWidth: 660, //画布宽度 canvasHeight: 228, //画布高度 blankX: 0, //曲线横向留白 blankT: 30, //文字横向留白 blankY: 35 //曲线纵向留白 &#125;; var setting = &#123; lineWidth: 1, //曲线粗细 lineColor: '#fff', //曲线颜色 base: 5, //区间基准值 textSize: 24, //文字大小 textOffSet: 34, //文字与曲线距离 textColor: '#fff', //文字颜色 font: 'arial' //文字字体 &#125; var getData = function(data) &#123; var _getData = [], _avarage; for (var _i = 0; _i &lt; data.length; _i++) &#123; _avarage = (data[_i][0] + data[_i][1]) / 2; _getData.push(_avarage); &#125; return _getData; &#125; var choseRank = function(getData) &#123; var _max = -Infinity, _min = Infinity, _res, _cur, _rank; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _cur = getData[_i]; if (_cur &gt; _max) &#123; _max = _cur; &#125; if (_cur &lt; _min) &#123; _min = _cur; &#125; &#125; _res = _max - _min; _rank = Math.round(_res / setting.base) + 1; return _rank * setting.base; &#125; var getYValues = function(start, control, end, X) &#123; var _q1, _q2, _q3, _t, _y; _q1 = 2 * start.x - 2 * control.x; _q2 = Math.sqrt(5 * start.x * start.x - 10 * start.x * control.x + start.x * end.x - start.x * X + 2 * control.x * X + 4 * control.x * control.x ); _q3 = 2 * start.x - 4 * control.x + 2 * end.x; if (_q3 !== 0) &#123; _t = (_q1 + _q2) / _q3; &#125; else &#123; _t = ( X - start.x) / (2*control.x - 2*start.x); &#125; if (_t &lt; 0) &#123; _t = -1 * _t; &#125; _y = start.y * (1 - _t) * (1 - _t) + control.y * 2 * (1 - _t) * _t + end.y * _t * _t; return _y; &#125; var setScale = function(num, cfg, setting) &#123; cfg.canvasWidth *= num; cfg.canvasHeight *= num; cfg.blankX *= num; cfg.blankT *= num; cfg.blankY *= num; setting.lineWidth *= num; setting.base *= num; setting.textSize *= num; setting.textOffSet *= num; &#125; var getSum = function(getData) &#123; var _sum = 0; for (var _i = 0; _i &lt; getData.length; _i++) &#123; _sum = _sum + getData[_i]; &#125; return _sum; &#125; var getSupportPoint = function(prev, next) &#123; return (prev + next) / 2; &#125; var draw_MAIN = function(canvas, data) &#123; setScale(2, cfg, setting); var _dataGot = getData(data); var _rank = choseRank(_dataGot); var _totalPoint = _dataGot.length; var _sum = getSum(_dataGot); var _avr = Math.round(_sum / _totalPoint); var _low = _avr - _rank / 2, _high = _avr + _rank / 2, _interval = (cfg.canvasWidth - cfg.blankX * 2) / (_totalPoint - 1), _intervalT = (cfg.canvasWidth - cfg.blankT * 2) / (_totalPoint - 1), _start = &#123;&#125;, _control = &#123;&#125;, _end = &#123;&#125;, _Y, _curSupport, _cur, _next; var _curPoint = cfg.blankX; var _curPointT = cfg.blankT; var getY = function(i) &#123; return cfg.canvasHeight - cfg.blankY - (_dataGot[i] - _low) * (cfg.canvasHeight - cfg.blankY * 2) / _rank; &#125; if (canvas.getContext) &#123; var _ctx = canvas.getContext('2d'); _ctx.imageSmoothingEnabled = true; _ctx.strokeStyle = setting.lineColor; _ctx.lineWidth = setting.lineWidth; _ctx.lineCap = 'round'; _ctx.font = setting.textSize + 'px ' + setting.font; _ctx.fillStyle = setting.textColor; _ctx.textAlign = 'center'; _ctx.textBaseline = 'middle'; _ctx.fillText(data[0][1] + \"°\", _curPointT, getY(0) - setting.textOffSet); _ctx.fillText(data[0][0] + \"°\", _curPointT, getY(0) + setting.textOffSet); _ctx.beginPath(); _ctx.moveTo(_curPoint, getY(0)); for (var _i = 0; _i &lt; _dataGot.length - 1; _i++) &#123; _cur = getY(_i + 1); _next = getY(_i + 2); _curSupport = getSupportPoint(_cur, _next); if (_i === 0) &#123; _start.x = _curPoint; _start.y = getY(0); _control.x = _curPoint + _interval; _control.y = _cur; _end.x = _curPoint + _interval * 1.5; _end.y = _curSupport; _Y = getYValues(_start, _control, _end, _curPoint + _interval); &#125; else if (_i &lt; _dataGot.length - 2) &#123; _start.x = _curPoint + _interval * 0.5; _start.y = getSupportPoint(getY(_i), getY(_i + 1)); _control.x = _curPoint + _interval; _control.y = _cur; _end.x = _curPoint + _interval * 1.5; _end.y = _curSupport; _Y = getYValues(_start, _control, _end, _control.x); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _Y = _cur; &#125; if (_i &lt; _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint + _interval, _cur, _curPoint + _interval * 1.5, _curSupport); &#125; else if (_i &gt;= _dataGot.length - 2) &#123; _ctx.quadraticCurveTo(_curPoint, getY(_i), _curPoint + _interval, _cur); &#125; _curPoint += _interval; _ctx.stroke(); _curPointT += _intervalT; _ctx.fillText(data[_i + 1][1] + \"°\", _curPointT, _Y - setting.textOffSet); _ctx.fillText(data[_i + 1][0] + \"°\", _curPointT, _Y + setting.textOffSet); &#125; &#125; &#125; draw_MAIN(canvas,data);&#125;"}]}